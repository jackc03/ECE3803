Question 2.1.1:
	The provided code is incorrect because line 2 does not set the value 
	which a is pointing to. Instead it sets the memory address of a to 3.
	
	void test1() {
		int* a = (int*) malloc(sizeof(int));
		*a = 3
		*a = *a + 2;
		printf("%d\n", *a);
	}


Question 2.1.2:
	Because of the way C syntax expects pointers to be declared, only a is
	a pointer. When declaring multiple variables on one line, C expects an
	'*' before each variable name.
	
	void test2() {
		int *a, *b;
		a = (int *) malloc(sizeof (int));
		b = (int *) malloc(sizeof (int));
		if (!(a && b)) {
		printf("Out of memory\n");
		exit(1);
		}
		*a = 2;
		*b = 3;
	}


Question 2.1.3:
	The current line to call malloc allocates 1000 bytes, not 1000 ints which
	are usually 4 bytes each. You need to multiply by sizeof(int)
	
	void test3() {
		int i;
		int* a = (int *) malloc(sizeof(int) * 1000);
		if (!a) {
		printf("Out of memory\n");
		exit(1);
		}
		for (i = 0; i < 1000; i++)
		*(i + a) = i;
	}
	

Question 2.1.4:
	Only one dimension of the array was malloc'd. To create a 2d array,
	each int* in the array must point to an array of size 100.
	
	void test4() {
		int** a = (int**) malloc(3 * sizeof(int*));
		for (int i = 0, i < 3; ++i) {
			a[i] = (int*) malloc(100 * sizeof(int));
		}
		a[1][1] = 5;
	}
	
	
Question 2.1.5:
	The current code checks if the memory address a points to is 0, not 
	if the value which a points to is 0; You just need to dereference a.
	
	void test5() {
		int *a = (int *) malloc(sizeof (int));
		scanf("%d", a);
		if (!*a)
		printf("Value is 0\n");
	}
	
	
Question 2.1.6:
	Printf was used incorrectly and did not give the identifiers on where
	to insert the integer using %d or %p.
	
	void test6() {
		int x = 5 + 9;
		printf("The sum of 5 + 9 is %d", x);
		printf("The sum of 5 + 9 is %p", &x);
	}
	
	
Question 2.1.7:
	The function declaration only declared the array as 1d.

	float test7(float **array, int width, int height) {
		float sum = 0;
		int i;
		for (i = 0; i < width; ++i)
			sum += array[height/2][i];
		return sum;
	}
	

Question 2.2.8:
	Amdahl's law is S = 1 / (1 - P + (P/N))
	
	Solving this for N:
		N = - S * P / (S - S * P - 1)
		
	Plugging in values gives us:
		N = - 3 * 0.5 / (3 - 3 * 0.5 - 1)
		N = - 1.5 / (0.5)
		N = -3
		
	Which means it is not possible to achieve that speedup with any amount 
	of processors for a program with 50% parallelizable.
	

Question 2.2.9:
	This approach falls apart when one iteration depends on the last.
	One example could be
	
	int main() {
		int arr[100] = {0};
		arr[0] = 1;
		for (int i = 1; i < 100; ++i)
			arr[i] = arr[i-1];
	}
	
	If this were parallelized, it would cause the array indexes > 0 to
	be incorrectly assigned 0, instead of 1 as intended.